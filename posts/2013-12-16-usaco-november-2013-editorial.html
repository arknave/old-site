<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>USACO November 2013 Editorial - Arknave</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="author" href="http://www.arknave.me" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
    </head>

    <body>
        <header>
            <div id="logo">
                <a href="../">Arknave</a>
            </div>
            <nav>
                <ul>
                    <li><a href="../">Home</a></li>
                    <li><a href="../about.html">About</a></li>
                    <li><a href="../archive.html">Archive</a></li>
                </ul>
            </nav>
        </header>

        <section id="content">
            <h2>USACO November 2013 Editorial</h2>

            <div class="info">
    Posted on December 16, 2013
</div>

<article class="post-content">
    <p><em>This is an editorial for USACO’s November 2013 competition. The solutions posted below are not official, and are not guaranteed to be correct in all cases.</em></p>
<p>I am a huge fan of USACO’s problems. Bessie and Farmer John have grown on me over the past few years. The problems are usually challenging, but not impossible. The competition is always evolving: this was the first contest to explicitly set guidelines for partial credit. While I wasn’t a fan of the shared bronze-silver problem, I appreciate the added diversity in problems.</p>
<h3 id="bronze-i-combination-lock"><a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=340">Bronze I: Combination Lock</a></h3>
<p>Given the low bounds on input (N ≤ 100), almost any algorithm will work. Here’s a C++ solution that tries every single combination and sees if it’s valid.</p>
<pre><code>bool within2(int a, int b) {
    return abs(a-b) &lt;= 2 || abs(a-b-N) &lt;= 2;
}

int main() {
    ifstream fin (&quot;combo.in&quot;);
    ofstream fout (&quot;combo.out&quot;);
    int a, b, c, x, y, z;
    fin &gt;&gt; N;
    fin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    fin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    int count = 0;
    for(int i=1;i&lt;=N;i++) {
        for(int j=1;j&lt;=N;j++) {
            for(int k=1;k&lt;=N;k++) {
                if((within2(i,a) &amp;&amp; within2(j,b) &amp;&amp; within2(k,c)) 
                || (within2(i,x) &amp;&amp; within2(j,y) &amp;&amp; within2(k,z))) {
                    count++; 
                }
            }
        }
    }
    fout &lt;&lt; count &lt;&lt; endl;
    return 0;
}</code></pre>
<p>Runtime: <strong>O(n^3)</strong></p>
<p>That said, there are many smarter ways to go about this. Looking at only one combination, there’s only five valid numbers for each slot. 5^3 = 125. Multiply this by the 2 codes to get 250 possible valid combinations. However, some of these are duplicates of each other. In order to filter out the duplicates, we can put the combinations into a set. Here’s some python code showing this.</p>
<pre><code>fin = open('combo.in', 'r')
fout = open('combo.out', 'w')

N = int(fin.readline())
fjcombo = map(int, fin.readline().split(' '))
mastercombo = map(int, fin.readline().split(' '))

s = set();
for i in range(fjcombo[0]-2, fjcombo[0]+3):
    for j in range(fjcombo[1]-2, fjcombo[1]+3):
        for k in range(fjcombo[2]-2, fjcombo[2]+3):
            s.add(((i+N)%N, (j+N)%N, (k+N)%N))

for i in range(mastercombo[0]-2, mastercombo[0]+3):
    for j in range(mastercombo[1]-2, mastercombo[1]+3):
        for k in range(mastercombo[2]-2, mastercombo[2]+3):
            s.add(((i+N)%N, (j+N)%N, (k+N)%N))

fout.write(str(len(s))+'\n')</code></pre>
<p>Runtime: <strong>O(1)</strong> (no matter what the input is, 250 elements are added to the set)</p>
<p>We can further improve this by calculating the number of overlapping elements instead of generating all of them, but at this point, the optimization is largely irrelevant.</p>
<h3 id="bronze-ii-goldilocks-and-the-cows"><a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=341">Bronze II: Goldilocks and the Cows</a></h3>
<p>Gah, I wrote a really good editorial for this but I forgot to save. Here’s the abridged version.</p>
<ol style="list-style-type: decimal">
<li>X, Y, and Z are constant for all cows. Therefore, if we know how many cows are cold, hot, and just right, we can calculate the amount of milk in constant time.</li>
<li>The only temperatures we need to consider are the ones at which a cow’s mood changes. All other temperatures are equivalent to one of those temperature borders.</li>
</ol>
<p>With those two rules, we can start with the temperature at -1, then increase it to each boundary, keeping track of the state of the cows overall. We don’t care about the individual cows, only the group as a whole. By sorting the temperatures and then checking each one, we can solve this problem as such (C++):</p>
<pre><code>struct event {
    int temp;
    bool is_start;
    bool operator&lt;(event other) const {
        return temp &lt; other.temp;
    }
};
int main() {
    ifstream fin (&quot;milktemp.in&quot;);
    ofstream fout (&quot;milktemp.out&quot;);
    fin &gt;&gt; N &gt;&gt; X &gt;&gt; Y &gt;&gt; Z;
    a = N;
    int t;
    vector&lt;event&gt; v;
    for(int i=0;i&lt;N;i++) {
        event e;
        fin &gt;&gt; t;
        e.temp = t;
        e.is_start = true;
        v.push_back(e);

        fin &gt;&gt; t;
        e.temp = t;
        e.is_start = false;
        v.push_back(e);
    }
    sort(v.begin(), v.end());
    int best = a*N;
    for(int i=0;i&lt;v.size();) {
        int j;
        for(j=i;v[i].temp == v[j].temp;j++) {
            if(v[j].is_start) {
                a--;
                b++;
            } else {
                b--;
                c++;
            }
        }
        i = j;
        best = max(best, a*X+b*Y+c*Z);
    }
    best = max(best, c*N);
    fout &lt;&lt; best &lt;&lt; endl;
    return 0;
}</code></pre>
<p>Runtime: <strong>O(nlogn)</strong></p>
<h3 id="bronze-iii-silver-i-no-cow"><a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=343">Bronze III / Silver I: No Cow</a></h3>
<p>Just an implementation problem. The code is pretty long, and Brian Dean has a much nicer solution than I do on the USACO web site.</p>
<h3 id="silver-ii-crowded-cows"><a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=344">Silver II: Crowded Cows</a></h3>
<p>First step seems obvious: sort the cows. But should we do it by x position or height? A decent naive approach would be to sort the cows by x position, then for each cow, scanning to each side, finding if the cow is crowded or not. This would be a <strong>O(n^2)</strong> runtime. Given USACO’s recently increased runtimes - this suffices!</p>
<pre><code>struct cow {
    int x, h;
    cow(int x, int h) : x(x), h(h) { }
    bool operator&lt;(cow const other) const {
        return x &lt; other.x;
    }
};

int main() {
    ifstream fin (&quot;crowded.in&quot;);
    ofstream fout (&quot;crowded.out&quot;);
    int N, D, x, h;
    fin &gt;&gt; N &gt;&gt; D;
    vector&lt;cow&gt; cowlist;
    for(int i=0;i&lt;N;i++) {
        fin &gt;&gt; x &gt;&gt; h;
        cowlist.push_back(cow(x, h));
    }
    sort(cowlist.begin(), cowlist.end());
    int count = 0;
    for(int i=1;i&lt;N-1;i++) {
        if(cowlist[i].h &gt;= 500000000) {
            continue; 
        }
        bool left = false;
        for(int j=i-1;j&gt;=0;j--) {
            if(cowlist[i].x - cowlist[j].x &gt; D) {
                break;
            }
            if(cowlist[j].h &gt;= cowlist[i].h * 2) {
                left = true;
                break;
            }
        }
        if(!left) {
            continue;
        }
        bool right = false;
        for(int j=i+1;j&lt;N;j++) {
            if(cowlist[j].x - cowlist[i].x &gt; D) {
                break;
            }
            if(cowlist[j].h &gt;= cowlist[i].h * 2) {
                right = true;
                break;
            }
        }
        if(left &amp;&amp; right) {
            count++;
        }
    }
    fout &lt;&lt; count &lt;&lt; endl;
    return 0;
}</code></pre>
</article>

        </section>
        <footer>
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
